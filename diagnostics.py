import pickle
import numpy as np
import timing
import NM.general as g
from matplotlib import pyplot as plt
from scipy.interpolate import interp1d
from scipy.optimize import minimize, Bounds
import NM.ssp_helpers as sh
import sys
from copy import deepcopy
from timeit import default_timer as timer

# run five inversions with amplitude of disturbance amp, source params
# return list of inversions

def f_test(f,rs, zs, amp, num_perts):
#    f= [40, 50, 60, 80, 145, 155]
#    f = np.linspace(50,150, 15)
    source_params = g.SourceParams(f, rs, zs)
    zr = [20.0, 25.0, 30.0, 35.0, 40.0, 45.0, 50.0, 55.0, 60.0, 65, 70.0, 75, 80]
 #   zr = np.arange(20, 80, 3)
    #`zr = [30, 32]

    # MEDIUM INFO
    rho1, rho2 = 1000, 1500
    D = [100]
    rhof = lambda z: np.piecewise(z, [z <= D[0], z > D[0]], [rho1, rho2])
    cb = 1600
    cbpert = 1600  # no change
    ssp = np.array([1500, 1490, 1485, 1480, 1479, 1478, 1480, 1481, 1482, 1483, 1485, 1486, 1489, 1492, 1492, 1499, 1503, 1503, 1503, 1504])
    mean_sspf = sh.get_sspf(ssp, D[0], cb)
    mean_cwsspf = sh.get_water_sspf(ssp, D[0])
    mean_medium = g.Medium(D, rhof, cb,  mean_sspf)

    # DOMAIN LIMITS ARE AUTOGENERATED FROM THE MEDIUM AND SOURCE PARAMS
    dz, dr = .10, .10

    # PERTURBATION
    mean_depth, var = 40,23
    num_profs = 100
    gparams = g.GaussPertParams(mean_depth, var, amp, num_profs)


    # COLLECT INTO SINGLE INPUT
    inp = g.GaussianModelInput(source_params, zr, mean_medium, cbpert, dz, dr, gparams, num_perts)
    invs = []
    for fs in f:
        tmp_inp = deepcopy(inp)
        tmp_inp.source_params.f = [fs]
# run inversion
        tmp_inv = g.gaussian_inv_run(tmp_inp)
        for sub_inv in tmp_inv:
            invs.append(sub_inv)
    return invs


def deriv_test(source_params, zr, mean_medium, cbpert, dom, dc, gparams):
    print(dc)
    print(gparams)
    
    # PERTURBATION
    mean_depth, var, amp = 40,23, 100
    num_profs = 100
    gparams = g.GaussPertParams(mean_depth, var, amp, num_profs)

    fs = source_params.f
    rms_derivs = []
    for f in fs:
        tmp_source_params = deepcopy(source_params)
        tmp_source_params.f = [f]
        kern1, kern2, deriv = dTdc(tmp_source_params, zr, mean_medium, cbpert, dom, dc, gparams)
        N = np.shape(deriv)[0]*np.shape(deriv)[1]
        rms = np.sqrt(np.sum(np.square(abs(deriv)))/N)
        rms_derivs.append(rms)
    return rms_derivs, kern1, kern2


def make_name(rs, zs):
    items = [rs, zs]
    items = [str(x) for x in items]
    name_string = '_'.join(items)
    return "pickled_runs/"+ name_string + '_inv.pickle'

def make_deriv_name(rs, zs):
    items = [rs, zs]
    items = [str(x) for x in items]
    name_string = '_'.join(items)
    return "pickled_runs/"+ name_string + '_rms.pickle'


# loop through all frequencies, source positions, and amplitudes
# pickle results
def generate_diagnostics(fs, rsrs, zszs, amp, num_perts):
    for rs in rsrs:
        for zs in zszs:
            fname = make_name(rs, zs)
            with open(fname, 'wb') as curr_file:
                inv = f_test(fs,rs, zs, amp, num_perts)
                pickle.dump(inv, curr_file)
                print("pickled inversion for freq "+str(fs))


# get results as a list of lists (each element is the return value 
# of an f_test call

def load_results(rsrs, zszs):
    results = []
    for rs in rsrs:
        for zs in zszs:
                fname = make_name(rs, zs)
                with open(fname, 'rb') as curr_file:
                    print(fname)
                    inv_list = pickle.load(curr_file)
                    for inv in inv_list:
                        results.append(inv)
    return results


def sort_results_by_amp(results):
    return



def view_results(inv):
    compare_kern(inv.zr, inv.c_errs, inv.dg)
    compare_pert(inv.E, inv.coeffs, inv.est_coeffs)
    inv.source_params.disp()
    return

def scatter_coeff(inv_list):
    fs = [x.source_params.f[0] for x in inv_list]
    print(fs)
    fs = set(fs)
    fs = [fs.pop() for i in range(len(fs))]
    print(fs)
    E = inv_list[0].E
    A = E[np.argmax(abs(E))]
    print(A)
    for f in fs:
        a = [A*x.coeffs[0] for x in inv_list if x.source_params.f[0] == f]
        b = [A*x.est_coeffs[0] for x in inv_list if x.source_params.f[0] == f]
        line = np.linspace(np.min(a), np.max(a), 20)
        plt.plot(line,line)
        plt.scatter(a, b, s=37)
    plt.legend(["f = " + str(int(x)) + ' Hz' for x in fs], loc = 'upper left')
#    plt.ylim(-10, 10)
    plt.title("Comparison of true perturbation to estimate")
    plt.xlabel("Amplitude of perturbation (m/s)")
    plt.ylabel("Estimated amplitude (m/s)")
    plt.show()


def kern_err(inv, print_out=False):
    errs = inv.c_errs
    dg = inv.dg
    diffs = errs - dg
    plt.plot(diffs)
    plt.show()
    return


def dTdc(source_params, zr, medium, cbpert, dom, dc, gaussparams=None):
    if gaussparams != None:
        pertf = sh.gauss_bulge(gaussparams.mean_depth, gaussparams.var, dc)  # gaussian perturbation of amplitude dc
        E, perts, coeffs = g.get_perts(gaussparams, 1, dom) # get eof matrix E by generating lots of random gaussian perts
        pert = pertf(dom.z) # get a pert vector
        coeff = np.matmul(np.linalg.inv(E), pert)
        pert1, coeff1 = abs(pert), abs(coeff) 
        pert2,  coeff2 = -1*pert, -1*coeff # ...
        pert1f, pert2f = sh.get_sspf(pert1,medium.D[0], medium.cb), sh.get_sspf(pert2, medium.D[0], medium.cb)
        ssp_plus = lambda z: medium.sspf(z) + pert1f(z)
        ssp_minus = lambda z: medium.sspf(z) + pert2f(z)
    else:
        ssp_plus = lambda z: medium.sspf(z) + dc
        ssp_minus = lambda z: medium.sspf(z) - dc
    pert_med1 = g.Medium(medium.D, medium.rhof, cbpert, ssp_plus)
    pert_med2 = g.Medium(medium.D, medium.rhof, cbpert, ssp_minus)
    start = timer()
    kern1, grn1 = g.twod_kern(pert_med1, zr, source_params, dom, range_ind=False)
    kern2, grn2 = g.twod_kern(pert_med2, zr, source_params, dom, range_ind=False )
    da = dom.dz*dom.dr
    end = timer()
    print("kernel calc. time", end - start)
    return da*kern1, da*kern2, da*(kern1- kern2) /2/dc
    

def compare_kern(zr, errs, dg, print_out=False):
    num_receivers = len(zr)
    num_runs = int(len(errs.real) / num_receivers)
    if print_out is True:
        for err, dgg in zip(errs, dg):
            print('err, dg: ', err, dgg)
    plt.rc('text', usetex=True)
    plt.subplot(2,1,1)
    print(num_runs)
    for i in range(num_runs):
        plt.plot(zr, errs.real[i:i+num_receivers])
        plt.plot(zr, dg.real[i:i+num_receivers])
    plt.ylabel(r'$\Delta G$.real') 
    plt.title(r'$\Delta G $ as predicted from $ \int_{V} \frac{\partial{G}}{\partial c} \Delta c dV$ \\ vs.\\ $\Delta G$ from two separate model runs')
    plt.subplot(2,1,2)
    for i in range(num_runs):
        plt.plot(zr, errs.imag[i:(i+num_receivers)])
        plt.plot(zr, dg.imag[i:(i+num_receivers)])
    plt.xlabel("Receiver depth (m)")
    plt.ylabel(r'$\Delta G$.imag') 
    plt.title(r'$\Delta G $.imag as predicted from $ \int_{V} \frac{\partial{G}}{\partial c} \Delta c dV$ \\ vs.\\ $\Delta G$ from two separate model runs')
    plt.subplots_adjust(hspace=1)
    plt.show()
    return


def compare_pert(E, coeffs, guess_coeffs):
    real_pert = E*coeffs[0] #+ E[:,1]+coeffs[1] + E[:,2] +coeffs[2]
    guess_pert = E*guess_coeffs[0]# + E[:,1]+guess_coeffs[1] + E[:,2] +guess_coeffs[2]
    plt.plot(real_pert)
    plt.plot(guess_pert)
    plt.show() 

def compare_est_err(inv_output):
    est_coeffs = inv_output.est_coeffs
    est_errs = inv_output.est_errs
    errs = inv_output.c_errs
    coeffs = inv_output.coeffs
    for err, est_err in zip(errs, est_errs):
        print("y tilda, y",est_err, err) 
    print("coeffs:", coeffs)
    print("tries:", est_coeffs)
    return

